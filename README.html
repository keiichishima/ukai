<h1>UKAI: The Centrally Controllable Distributed Local Storage</h1>

<h2>Copyright Notice</h2>

<p>Copyright 2013 IIJ Innovation Institute Inc. All rights reserved.</p>

<p>Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:</p>

<ul>
<li>Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.</li>
</ul>

<p>THIS SOFTWARE IS PROVIDED BY IIJ INNOVATION INSTITUTE INC. ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL IIJ INNOVATION INSTITUTE INC. OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>

<h2>Introduction</h2>

<p>UKAI is an implementation of the concept of 'Centrally Controllable
Distributed Local Storage' as a virtual machine disk image storage.
UKAI provides a filesystem interface to a hypervisor.  A hypervisor
use the files stored in the UKAI filesystem as a virtual machine disk
image file.  The UKAI filesystem is not a POSIX filesystem.  It only
provides limited but enough set of filesystem operations for virtual
machine disk image storage.</p>

<p>The UKAI filesystem is a kind of distributed storage system.  Unlike
other major distributed file/storage systems, the UKAI filesystem is
not <em>autonomous</em> distributed system.  It is fully manual controlled
distributed filesystem.  You must configure which file should be
stored on which node.  In other words, you have full control on data
placement/replacement which is sometimes important when naive
management is required.</p>

<p>For example, assuming that you have geographically distributed
datacenters for virtualization services.  In that case, you may want
to migrate a virtual machie from a hypervisor to a different
hypervisor which is located far place geographically.  The disk image
of the virtual machine must be accessible from any location, but
probably you want some locallity for better disk I/O performance.
Using the UKAI filesystem, you can collect your virtual machine disk
image data to UKAI storage nodes located near to the running virtual
machine.</p>

<h2>Installation</h2>

<p>UKAI is a Python program built on top of the <a href="http://fuse.sourceforge.net" title="FUSE: Filesystem in Userspace">FUSE</a> mechanism.  The
following software modules are required to run the UKAI filesystem.</p>

<ul>
<li><a href="http://www.python.org/">Python</a>: You know.</li>
<li><a href="http://fuse.sourceforge.net" title="FUSE: Filesystem in Userspace">FUSE</a>: Filesystem in Userspace.</li>
<li><a href="https://github.com/terencehonles/fusepy">fusepy</a>: A Python module that provides a imple interface to FUSE.</li>
<li><a href="http://alastairs-place.net/projects/netifaces/">netifaces</a>: A portable access to network interfaces from Python.</li>
</ul>

<p>In some environment, you may need to join the 'fuse' group and may
need to configure the '/etc/fuse.conf' file to include the following
line to disclose the filesystem to other users than the user running
the UKAI filesystem.</p>

<pre><code>user_allow_other
</code></pre>

<h2>Configuration</h2>

<p>Before running the UKAI filesystem, you need to check the
<code>ukai_config.py</code> file and setup appropriate parameters defined in the
file.  The following parameters are configurable.</p>

<ul>
<li><code>image_root</code>: The path where virtual machine disk image data is
stored.</li>
<li><code>metadata_root</code>: The path where the metadata information of
disk images is located.</li>
<li><code>blockname_format</code>: The filename format of each piece of blocks.</li>
<li><code>control_port</code>: The port number of the contorl interface to get/set
internal information of the UKAI filesystem.</li>
<li><code>proxy_port</code>: The port number of the proxy program when receiving
read/write requests from remote UKAI nodes.</li>
</ul>

<h2>Prepare a Disk Image</h2>

<p>At this moment, there is no handy way to prepare a disk image for the
UKAI filesystem.  You have to prepare all the necessary pieces by hand.</p>

<p>The things you have to do is the following two.</p>

<ul>
<li>Prepare a metadata file for a disk image</li>
<li>Prepare files used as a storage space of the disk image</li>
</ul>

<h3>Prepare Metadata</h3>

<p>The metadata is represented in a JSON format like below.</p>

<pre><code>{
    "name": "image01",
    "size": 8000000000,
    "block_size": 50000000,
    "blocks": [
        {
            "192.168.0.100": {
                "synced": true
            }
        },
        {
            "192.168.0.100": {
                "synced": true
            }
        }
        (continue 158 times)
    ]
}
</code></pre>

<p>The <code>name</code> key is a name of the disk image.  The <code>size</code> key is the
total size of the disk image.  In the above example, 8GB disk is
defined.  The <code>block_size</code> key is the size of a block.  The disk image
will be divided into pieces of files based on the value of the
<code>block_size</code> key.  The <code>blocks</code> key is a list of location information
of each block.  Each block can have multiple UKAI remote sotrage
endpoint.  The 'synced' flag is shows the status if the data is
up-to-date or not.</p>

<h3>Prepare a Disk Image Files</h3>

<p>Once you've created the metadata file, put it to the
<code>UKAIConfig['metadata_root']</code> path.</p>

<p>You also need to prepare initial disk image files as defined in the
metadata file.  In the above example, you have to prepare 160 files
under the <code>UKAIConfig['image_root']/image01/</code> path of the
<code>192.168.0.100</code> node.  The filename of each block is defiend by
<code>UKAIConfig['blockname_format']</code>, defaults to <code>%016d</code>.  The block file
can have any contents since at the beginning, the contents doesn't
have any meaning.  You may create the files like below.</p>

<pre><code>for idx in `seq 0 159`
do
    dd if=/dev/zero of=`printf %016d ${idx}`
done
</code></pre>

<h2>Start the UKAI filesystem</h2>

<p>To start the UKAI filesystem, you call the main function of the
<code>ukai.py</code> with the path to mount the filesystem.</p>

<pre><code>$ python ukai.py /ukai
</code></pre>

<p>You also need to run the same program under every UKAI remote nodes
defined in metadata files of your disk images.</p>

<h2>Insert a Disk Image</h2>

<p>Initially, there is no disk image attached to the UKAI filesystem.  To
add the disk image (which you've prepared with a metadata file and
image data file), follow the below instruction.</p>

<pre><code>$ python
&gt;&gt;&gt; import xmlrpclib
&gt;&gt;&gt; s = xmlrpclib.ServerProxy('http://127.0.0.1:22221')
&gt;&gt;&gt; s.add_image('image01')
&gt;&gt;&gt; exit()
</code></pre>

<p>The port number of the XML-RPC server is the value defined as the
<code>UKAIConfig['control_port']</code> value.  The image name used with the
<code>add_image</code> method is the name of the disk image you defined in your
metadata file.</p>

<p>We will prepare friendlier control command in the future.</p>

<p>Once you complete the above process, you will see that your image is
added under the UKAI mount point.</p>

<h2>Using as a Disk Image</h2>

<p>The image file can be used directly as a disk image file.  The
following is an example of the libvirt style disk definition.</p>

<pre><code>&lt;disk type='file' device='disk'&gt;
  &lt;driver name='qemu' type='raw'/&gt;
  &lt;source file='/ukai/image01'/&gt;
  &lt;target dev='vda' bus='virtio'/&gt;
  &lt;alias name='virtio-disk0'/&gt;
  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0'/&gt;
&lt;/disk&gt;
</code></pre>

<hr />
